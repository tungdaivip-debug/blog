<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeteVN | TeteVN M√πa Thu </title>
    <meta name="author" content="V≈© Th√†nh Trung">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Montserrat:wght@300;400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --gold: #ffd700;
            --red-fire: #ff4500;
            --cyan-glow: #00f3ff;
            --deep-bg: #050508;
        }

        body {
            background-color: var(--deep-bg);
            color: #e0e0e0;
            font-family: 'Montserrat', sans-serif;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
        }

        /* Typography */
        h1, h2, h3, .brand-font { font-family: 'Cinzel', serif; }
        .post-title { font-family: 'Playfair Display', serif; }

        /* Canvas n·ªÅn */
        #myth-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 0;
        }

        /* UI L·ªõp tr√™n */
        #content-layer {
            position: relative;
            z-index: 10;
            pointer-events: none; /* Cho ph√©p click xuy√™n qua v√πng tr·ªëng */
        }
        
        /* Cho ph√©p click v√†o c√°c element c·ª• th·ªÉ */
        a, button, .blog-card {
            pointer-events: auto;
        }

        /* Glassmorphism Cards */
        .blog-card {
            background: rgba(15, 20, 35, 0.7);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 215, 0, 0.15);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }
        .blog-card:hover {
            transform: translateY(-8px) scale(1.02);
            border-color: var(--cyan-glow);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.15);
        }

        /* Hi·ªáu ·ª©ng rung m√†n h√¨nh khi chi·∫øn ƒë·∫•u */
        .shake-screen {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-6px, 0, 0); }
            40%, 60% { transform: translate3d(6px, 0, 0); }
        }

        /* Flash Effect khi va ch·∫°m m·∫°nh */
        .flash-effect {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; z-index: 999;
        }
        .flash-active {
            animation: flash 0.2s ease-out;
        }
        @keyframes flash {
            0% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        /* Navigation & Text */
        .nav-link { position: relative; }
        .nav-link::after {
            content: ''; position: absolute; bottom: -5px; left: 0; width: 0; height: 1px;
            background: var(--cyan-glow); transition: width 0.3s;
        }
        .nav-link:hover::after { width: 100%; }

        .text-gradient {
            background: linear-gradient(135deg, #ffd700, #ff8c00); /* Chuy·ªÉn sang t√¥ng v√†ng cam m√πa thu */
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 800;
        }
        
        /* Destructible Text Styles */
        .shattered {
            opacity: 0;
            transform: scale(0.8) skew(20deg);
            filter: blur(5px);
            transition: all 0.3s ease-out;
        }
        .restore-anim { animation: restore 1.5s ease-out forwards; }
        @keyframes restore {
            0% { opacity: 0; filter: blur(10px); transform: translateY(20px); }
            100% { opacity: 1; filter: blur(0); transform: translateY(0); }
        }
    </style>
</head>
<body id="main-body">

    <div id="flash-overlay" class="flash-effect"></div>
    <canvas id="myth-canvas"></canvas>

    <div id="content-layer">
        <!-- Navigation -->
        <nav class="fixed w-full top-0 bg-black/60 backdrop-blur-md border-b border-white/5 z-50">
            <div class="max-w-7xl mx-auto px-6">
                <div class="flex items-center justify-between h-20">
                    <span class="destructible text-3xl font-bold brand-font text-white tracking-widest cursor-pointer hover:text-cyan-400 transition">
                        TETEVN
                    </span>
                    <div class="hidden md:flex space-x-10 text-sm font-medium tracking-wide">
                        <a href="#" class="nav-link text-gray-300 hover:text-white transition">TRANG CH·ª¶</a>
                        <a href="#featured" class="nav-link text-gray-300 hover:text-white transition">M√ôA THU</a>
                        <a href="#contact" class="px-6 py-2 border border-cyan-500/50 rounded-full text-cyan-400 hover:bg-cyan-500/10 transition">LI√äN H·ªÜ</a>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Hero Section -->
        <header class="min-h-screen flex items-center justify-center relative">
            <div class="text-center px-6 max-w-5xl mx-auto mt-[-5vh]">
                <p class="destructible text-gold/80 text-sm tracking-[0.4em] mb-6 uppercase font-bold">V≈© Th√†nh Trung - T·∫£n VƒÉn</p>
                <h1 class="destructible text-6xl md:text-9xl font-bold mb-8 text-white leading-none tracking-tight shadow-lg">
                    KH√öC T√åNH<br>
                    <span class="text-gradient drop-shadow-[0_0_15px_rgba(255,215,0,0.5)]">THU H√Ä N·ªòI</span>
                </h1>
                <p class="destructible text-gray-300 text-lg md:text-2xl mb-12 font-light leading-relaxed max-w-2xl mx-auto italic">
                    "M√πa thu - m√πa c·ªßa nh·ªØng n·ªói nh·ªõ kh√¥ng t√™n, c·ªßa m√πi hoa s·ªØa n·ªìng n√†n g√≥c ph·ªë, v√† nh·ªØng chi·ªÅu gi√≥ heo may se l·∫°nh."
                </p>
                <a href="#featured" class="destructible inline-block px-10 py-4 border border-white/20 hover:border-gold hover:bg-gold/10 hover:text-gold text-white transition duration-300 rounded-sm text-sm tracking-[0.2em] uppercase backdrop-blur-sm">
                    ƒê·ªçc B√†i Vi·∫øt
                </a>
            </div>
        </header>

        <!-- Blog Grid -->
        <section id="featured" class="py-32 max-w-7xl mx-auto px-6">
            <div class="flex items-end justify-between mb-16 border-b border-white/10 pb-6">
                <h2 class="destructible text-5xl font-bold text-white brand-font">G√≥c Nh√¨n M√πa Thu</h2>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <!-- Card 1 -->
                <article class="destructible blog-card rounded-2xl p-1">
                    <div class="bg-gray-900/50 rounded-xl p-8 h-full flex flex-col">
                        <div class="text-gold text-4xl mb-6">üçÇ</div>
                        <h3 class="post-title text-2xl text-white mb-4">H∆∞∆°ng Hoa S·ªØa</h3>
                        <p class="text-gray-400 text-sm leading-relaxed flex-grow">
                            Th√°ng 10 v·ªÅ, H√† N·ªôi l·∫°i n·ªìng n√†n trong h∆∞∆°ng hoa s·ªØa. M√πi h∆∞∆°ng ·∫•y len l·ªèi v√†o t·ª´ng con ng√µ nh·ªè, ƒë√°nh th·ª©c nh·ªØng k√Ω ·ª©c ng·ªß qu√™n.
                        </p>
                        <a href="#" class="mt-6 text-sm text-gold uppercase tracking-wider hover:underline">ƒê·ªçc ti·∫øp -></a>
                    </div>
                </article>

                <!-- Card 2 -->
                <article class="destructible blog-card rounded-2xl p-1">
                    <div class="bg-gray-900/50 rounded-xl p-8 h-full flex flex-col">
                        <div class="text-cyan-400 text-4xl mb-6">‚òï</div>
                        <h3 class="post-title text-2xl text-white mb-4">Cafe Ph·ªë C·ªï</h3>
                        <p class="text-gray-400 text-sm leading-relaxed flex-grow">
                            Ng·ªìi b√™n ban c√¥ng c≈©, nh√¢m nhi t√°ch n√¢u n√≥ng, ng·∫Øm nh√¨n d√≤ng ng∆∞·ªùi v·ªôi v√£ trong c√°i n·∫Øng hanh v√†ng ƒë·∫∑c tr∆∞ng c·ªßa m√πa thu.
                        </p>
                        <a href="#" class="mt-6 text-cyan-400 uppercase tracking-wider hover:underline">ƒê·ªçc ti·∫øp -></a>
                    </div>
                </article>

                <!-- Card 3 -->
                <article class="destructible blog-card rounded-2xl p-1">
                    <div class="bg-gray-900/50 rounded-xl p-8 h-full flex flex-col">
                        <div class="text-red-500 text-4xl mb-6">üèÆ</div>
                        <h3 class="post-title text-2xl text-white mb-4">Huy·ªÅn Tho·∫°i TrƒÉng R·∫±m</h3>
                        <p class="text-gray-400 text-sm leading-relaxed flex-grow">
                            M√πa thu c≈©ng l√† m√πa c·ªßa nh·ªØng huy·ªÅn tho·∫°i. H√¨nh ·∫£nh R·ªìng bay Ph∆∞·ª£ng m√∫a tr√™n b·∫ßu tr·ªùi ƒë√™m nh∆∞ nh·∫Øc nh·ªü v·ªÅ c·ªôi ngu·ªìn vƒÉn h√≥a.
                        </p>
                        <a href="#" class="mt-6 text-red-500 uppercase tracking-wider hover:underline">ƒê·ªçc ti·∫øp -></a>
                    </div>
                </article>
            </div>
        </section>
        
        <!-- Footer -->
        <footer class="py-12 text-center text-gray-600 text-sm border-t border-white/5 bg-black/80">
            <p>¬© 2025 TeteVN. Vi·∫øt b·ªüi V≈© Th√†nh Trung.</p>
            <p class="mt-2">Li√™n h·ªá: <a href="mailto:trung@tetevn.com" class="text-cyan-600 hover:text-cyan-400">trung@tetevn.com</a></p>
        </footer>
    </div>

    <!-- ENGINE X·ª¨ L√ù (Gi·ªØ nguy√™n to√†n b·ªô hi·ªáu ·ª©ng R·ªìng Ph∆∞·ª£ng) -->
    <script>
        window.onload = function() {
            const canvas = document.getElementById('myth-canvas');
            const ctx = canvas.getContext('2d');
            const flashOverlay = document.getElementById('flash-overlay');

            let width, height;
            let particles = [];
            
            // --- C·∫§U H√åNH (ƒê√É N√ÇNG C·∫§P T·ªêC ƒê·ªò) ---
            const CONFIG = {
                dragonSpeed: 7,       // TƒÉng t·ªëc ƒë·ªô R·ªìng (C≈©: 3)
                phoenixSpeed: 9,      // TƒÉng t·ªëc ƒë·ªô Ph∆∞·ª£ng (C≈©: 4)
                battleDistance: 450,  // TƒÉng t·∫ßm chi·∫øn ƒë·∫•u
                attackChance: 0.08,   // TƒÉng t·ªâ l·ªá tung chi√™u
            };

            function resize() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', resize);
            resize();

            // --- HELPER FUNCTIONS ---
            function dist(x1, y1, x2, y2) { return Math.sqrt((x2-x1)**2 + (y2-y1)**2); }
            function random(min, max) { return Math.random() * (max - min) + min; }
            function triggerShake() {
                document.body.classList.add('shake-screen');
                setTimeout(() => document.body.classList.remove('shake-screen'), 500);
            }
            function triggerFlash() {
                flashOverlay.classList.add('flash-active');
                setTimeout(() => flashOverlay.classList.remove('flash-active'), 200);
            }

            // --- PARTICLE SYSTEM ---
            class Particle {
                constructor(x, y, color, type) {
                    this.x = x; this.y = y;
                    this.color = color;
                    this.type = type; 
                    // TƒÉng t·ªëc ƒë·ªô h·∫°t ƒë·ªÉ ph√π h·ª£p v·ªõi t·ªëc ƒë·ªô bay
                    const speed = type === 'beam' ? 25 : (random(4, 10)); 
                    const angle = random(0, Math.PI*2);
                    
                    if(type === 'beam') {
                        this.vx = Math.cos(angle) * 5; 
                        this.vy = Math.sin(angle) * 5;
                        this.life = 0.4;
                    } else {
                        this.vx = Math.cos(angle) * speed;
                        this.vy = Math.sin(angle) * speed;
                        this.life = 1.0;
                    }
                    this.size = random(2, 6);
                }
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life -= 0.03; // Tan bi·∫øn nhanh h∆°n ch√∫t
                    if(this.type === 'spark') this.vy += 0.2; 
                }
                draw(ctx) {
                    ctx.save();
                    ctx.globalAlpha = this.life;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            // --- BEAM ATTACK ---
            class EnergyBeam {
                constructor(startX, startY, endX, endY) {
                    this.sx = startX; this.sy = startY;
                    this.ex = endX; this.ey = endY;
                    this.life = 8; // Nhanh h∆°n
                }
                draw(ctx) {
                    if(this.life <= 0) return;
                    this.life--;
                    
                    ctx.save();
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = "#00f3ff";
                    ctx.strokeStyle = `rgba(0, 243, 255, ${this.life/8})`;
                    ctx.lineWidth = random(4, 12); // To h∆°n
                    ctx.lineCap = 'round';
                    
                    ctx.beginPath();
                    ctx.moveTo(this.sx, this.sy);
                    
                    let currX = this.sx, currY = this.sy;
                    const steps = 8;
                    const dx = (this.ex - this.sx) / steps;
                    const dy = (this.ey - this.sy) / steps;
                    
                    for(let i=0; i<steps; i++) {
                        currX += dx + random(-30, 30); // Gi·∫≠t m·∫°nh h∆°n
                        currY += dy + random(-30, 30);
                        ctx.lineTo(currX, currY);
                    }
                    ctx.lineTo(this.ex, this.ey);
                    ctx.stroke();

                    ctx.strokeStyle = `rgba(255, 255, 255, ${this.life/8})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.restore();
                }
            }
            let activeBeams = [];

            // --- DRAGON CLASS (Speed Up) ---
            class Dragon {
                constructor() {
                    this.segments = [];
                    this.len = 60; 
                    for(let i=0; i<this.len; i++) 
                        this.segments.push({x: -100, y: height/2, angle: 0});
                    
                    this.target = {x: width/2, y: height/2};
                    this.angle = 0;
                    this.wobble = 0;
                    this.jawOpen = 0; 
                }

                update(enemy) {
                    let isAttacking = false;
                    const head = this.segments[0];
                    const dToEnemy = dist(head.x, head.y, enemy.x, enemy.y);

                    if (dToEnemy < CONFIG.battleDistance) {
                        this.target = {x: enemy.x, y: enemy.y};
                        if (dToEnemy < 300 && Math.random() < CONFIG.attackChance) {
                            isAttacking = true;
                            this.jawOpen = 15; 
                            activeBeams.push(new EnergyBeam(head.x, head.y, enemy.x, enemy.y));
                            for(let i=0; i<8; i++) 
                                particles.push(new Particle(enemy.x, enemy.y, '#00f3ff', 'spark'));
                        }
                    } else {
                        if (dist(head.x, head.y, this.target.x, this.target.y) < 200) { // ƒê·ªïi ƒë√≠ch nhanh h∆°n
                            this.target = {x: random(100, width-100), y: random(100, height-100)};
                        }
                        if(this.jawOpen > 0) this.jawOpen--;
                    }

                    const dx = this.target.x - head.x;
                    const dy = this.target.y - head.y;
                    const targetAngle = Math.atan2(dy, dx);
                    
                    let diff = targetAngle - this.angle;
                    while(diff <= -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;
                    
                    const turnSpeed = isAttacking ? 0.15 : 0.08; // Quay ƒë·∫ßu c·ª±c nhanh
                    this.angle += diff * turnSpeed;
                    
                    this.wobble += 0.3; // U·ªën l∆∞·ª£n nhanh h∆°n nhi·ªÅu (Animation Speed Up)
                    
                    // Boost t·ªëc ƒë·ªô khi t·∫•n c√¥ng
                    const speed = isAttacking ? CONFIG.dragonSpeed * 1.5 : CONFIG.dragonSpeed;

                    head.x += Math.cos(this.angle) * speed;
                    head.y += Math.sin(this.angle) * speed;

                    // IK Segments
                    for(let i=1; i<this.len; i++) {
                        const prev = this.segments[i-1];
                        const curr = this.segments[i];
                        const angle = Math.atan2(prev.y - curr.y, prev.x - curr.x);
                        curr.angle = angle;
                        const dist = 12; 
                        curr.x = prev.x - Math.cos(angle) * dist;
                        curr.y = prev.y - Math.sin(angle) * dist;
                    }
                }

                draw(ctx) {
                    ctx.save();
                    ctx.shadowBlur = 30; // H√†o quang m·∫°nh h∆°n
                    ctx.shadowColor = "rgba(255, 215, 0, 0.7)";

                    ctx.beginPath();
                    ctx.strokeStyle = "#b8860b"; 
                    ctx.lineWidth = 2;
                    for(let i=4; i<this.len-5; i++) {
                        const s = this.segments[i];
                        const spineLen = 25 * (1 - i/this.len) + 5;
                        const topX = s.x + Math.cos(s.angle - Math.PI/2) * spineLen;
                        const topY = s.y + Math.sin(s.angle - Math.PI/2) * spineLen;
                        if(i===4) ctx.moveTo(topX, topY);
                        else ctx.lineTo(topX, topY);
                    }
                    ctx.stroke();

                    for(let i=this.len-1; i>=0; i--) {
                        const s = this.segments[i];
                        const size = 22 * (1 - i/this.len) + 6;
                        
                        if([10, 30].includes(i)) {
                            this.drawClaw(ctx, s, 1, i); 
                            this.drawClaw(ctx, s, -1, i);
                        }

                        const grad = ctx.createRadialGradient(s.x, s.y, size*0.3, s.x, s.y, size);
                        grad.addColorStop(0, '#ffd700'); 
                        grad.addColorStop(0.7, '#daa520'); 
                        grad.addColorStop(1, '#b8860b'); 
                        
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(s.x, s.y, size, 0, Math.PI*2);
                        ctx.fill();
                        
                        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                    }

                    this.drawHead(ctx);
                    ctx.restore();
                }

                drawClaw(ctx, seg, side, index) {
                    const angle = seg.angle + side * 1.3;
                    const armLen = 25;
                    const kneeX = seg.x + Math.cos(angle) * armLen;
                    const kneeY = seg.y + Math.sin(angle) * armLen;
                    
                    // Ch√¢n khua kho·∫Øng nhanh h∆°n (x3 t·ªëc ƒë·ªô)
                    const move = Math.sin(Date.now() * 0.015 + index) * 12;
                    const footX = kneeX + Math.cos(seg.angle + side * 0.5) * (15 + move);
                    const footY = kneeY + Math.sin(seg.angle + side * 0.5) * (15 + move);

                    ctx.strokeStyle = '#daa520';
                    ctx.lineWidth = 5;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(seg.x, seg.y);
                    ctx.lineTo(kneeX, kneeY);
                    ctx.lineTo(footX, footY);
                    ctx.stroke();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(footX, footY);
                    ctx.lineTo(footX + 7, footY + 5);
                    ctx.moveTo(footX, footY);
                    ctx.lineTo(footX + 7, footY - 5);
                    ctx.stroke();
                }

                drawHead(ctx) {
                    const head = this.segments[0];
                    ctx.translate(head.x, head.y);
                    ctx.rotate(this.angle);

                    ctx.fillStyle = '#b8860b';
                    for(let i=0; i<5; i++) {
                        ctx.beginPath();
                        ctx.ellipse(-15 - i*4, 0, 12, 28 - i*2, 0, 0, Math.PI*2);
                        ctx.fill();
                    }

                    ctx.save();
                    ctx.rotate(this.jawOpen * 0.02); 
                    ctx.fillStyle = '#b8860b';
                    ctx.beginPath();
                    ctx.moveTo(0, 5);
                    ctx.quadraticCurveTo(20, 15, 30, 10); 
                    ctx.lineTo(10, 20);
                    ctx.fill();
                    ctx.restore();

                    ctx.save();
                    ctx.rotate(-this.jawOpen * 0.02);
                    
                    const headGrad = ctx.createLinearGradient(-20, 0, 35, 0);
                    headGrad.addColorStop(0, '#daa520');
                    headGrad.addColorStop(1, '#ffd700');
                    ctx.fillStyle = headGrad;

                    ctx.beginPath();
                    ctx.moveTo(-20, -15);
                    ctx.lineTo(35, -10); 
                    ctx.lineTo(35, 10);
                    ctx.lineTo(-20, 15);
                    ctx.fill();
                    
                    ctx.fillStyle = '#8b4513';
                    ctx.beginPath();
                    ctx.arc(32, -5, 3, 0, Math.PI*2);
                    ctx.fill();

                    ctx.strokeStyle = '#8b4513';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(0, -15); ctx.lineTo(-15, -35); ctx.lineTo(-5, -50);
                    ctx.moveTo(-15, -35); ctx.lineTo(-25, -45);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 15); ctx.lineTo(-15, 35); ctx.lineTo(-5, 50);
                    ctx.moveTo(-15, 35); ctx.lineTo(-25, 45);
                    ctx.stroke();

                    ctx.fillStyle = '#ff4500';
                    ctx.shadowColor = '#ff4500';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.ellipse(5, -8, 5, 3, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    // R√¢u bay ph·∫ßn ph·∫≠t trong gi√≥ (nhanh h∆°n)
                    const wave = Math.sin(Date.now()*0.02)*15;
                    ctx.moveTo(30, -5); 
                    ctx.bezierCurveTo(50, -25, 60, -40+wave, 80, -50+wave);
                    ctx.moveTo(30, 5); 
                    ctx.bezierCurveTo(50, 25, 60, 40+wave, 80, 50+wave);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // --- PHOENIX CLASS (Speed Up) ---
            class Phoenix {
                constructor() {
                    this.x = width + 100;
                    this.y = height/4;
                    this.angle = Math.PI;
                    this.target = {x: width/2, y: height/2};
                    this.trails = [[], [], [], [], []]; 
                    this.wingCycle = 0;
                    this.flashTimer = 0;
                }

                update(enemy) {
                    const dToEnemy = dist(this.x, this.y, enemy.x, enemy.y);
                    let speed = CONFIG.phoenixSpeed;

                    if (dToEnemy < CONFIG.battleDistance) {
                        this.target = {x: enemy.x, y: enemy.y};
                        if (dToEnemy < 300 && Math.random() < CONFIG.attackChance) {
                             particles.push(new Particle(this.x, this.y, '#ff4500', 'spark')); 
                             this.flashTimer = 5; 
                        }
                        speed *= 1.3; // Boost m·∫°nh h∆°n khi chi·∫øn ƒë·∫•u
                    } else {
                        if (dist(this.x, this.y, this.target.x, this.target.y) < 200) {
                            this.target = {x: random(100, width-100), y: random(100, height-100)};
                        }
                    }

                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const tAngle = Math.atan2(dy, dx);
                    
                    let diff = tAngle - this.angle;
                    while(diff <= -Math.PI) diff += Math.PI*2;
                    while(diff > Math.PI) diff -= Math.PI*2;
                    this.angle += diff * 0.1; // Quay ƒë·∫ßu r·∫•t nhanh

                    this.x += Math.cos(this.angle) * speed;
                    this.y += Math.sin(this.angle) * speed;

                    for(let i=0; i<5; i++) {
                        // ƒêu√¥i t·∫°o ra nhi·ªÅu h·∫°t h∆°n khi bay nhanh
                        this.trails[i].push({x: this.x, y: this.y, life: 1, width: random(10, 20)});
                        if(this.trails[i].length > 30) this.trails[i].shift(); // ƒêu√¥i ng·∫Øn l·∫°i ch√∫t ƒë·ªÉ ƒë·ª° lag
                        this.trails[i].forEach(t => {
                            t.life -= 0.04; // Tan nhanh h∆°n
                            t.width *= 0.95;
                        });
                    }

                    this.wingCycle += 0.5; // V·ªó c√°nh r·∫•t nhanh
                    if(this.flashTimer > 0) this.flashTimer--;
                }

                draw(ctx) {
                    ctx.save();
                    ctx.shadowBlur = 35; // H√†o quang l·ª≠a
                    ctx.shadowColor = "#ff4500";

                    ctx.lineCap = 'round';
                    for(let i=0; i<5; i++) {
                        const offset = (i-2) * 8; 
                        const trail = this.trails[i];
                        
                        for(let j=0; j<trail.length-1; j++) {
                            const t = trail[j];
                            const next = trail[j+1];
                            const wave = Math.sin(j * 0.3 + i + Date.now()*0.02) * 15; // S√≥ng ƒëu√¥i nhanh
                            
                            ctx.beginPath();
                            ctx.lineWidth = t.width * t.life;
                            const grad = ctx.createLinearGradient(t.x+wave, t.y+offset, next.x+wave, next.y+offset);
                            grad.addColorStop(0, `rgba(255, 69, 0, ${t.life})`); 
                            grad.addColorStop(1, `rgba(255, 215, 0, ${t.life})`); 
                            ctx.strokeStyle = grad;
                            
                            ctx.moveTo(t.x + wave, t.y + offset);
                            ctx.lineTo(next.x + wave, next.y + offset);
                            ctx.stroke();
                        }
                    }

                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);

                    const wingY = Math.sin(this.wingCycle) * 45;
                    const wingFold = Math.cos(this.wingCycle) * 20;
                    
                    this.drawOneWing(ctx, -1, wingY * 0.7, wingFold, '#cd5c5c', '#ff4500');
                    
                    const color1 = this.flashTimer > 0 ? '#ffff00' : '#ff8c00';
                    const color2 = this.flashTimer > 0 ? '#ff4500' : '#ff0000';
                    this.drawOneWing(ctx, 1, wingY, wingFold, color1, color2);

                    this.drawBody(ctx);

                    ctx.restore();
                }

                drawOneWing(ctx, dir, yOffset, xFold, color1, color2) {
                    ctx.save();
                    ctx.scale(1, dir); 
                    
                    const grad = ctx.createLinearGradient(0, 0, -100, -100);
                    grad.addColorStop(0, color1);
                    grad.addColorStop(1, color2);
                    ctx.fillStyle = grad;

                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.bezierCurveTo(-20 + xFold, -60 - yOffset, -60, -100 - yOffset, -120, -60 - yOffset*0.5); 
                    ctx.bezierCurveTo(-100, -40, -80, -20, -40, -10); 
                    ctx.bezierCurveTo(-30, 0, -10, 10, 10, 0); 
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(255,255,0,0.5)';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(0,0); ctx.quadraticCurveTo(-30, -30-yOffset, -80, -50-yOffset);
                    ctx.moveTo(0,0); ctx.quadraticCurveTo(-20, -20-yOffset, -50, -30-yOffset);
                    ctx.stroke();

                    ctx.restore();
                }

                drawBody(ctx) {
                    const bodyGrad = ctx.createLinearGradient(0,0, 30,0);
                    bodyGrad.addColorStop(0, '#ff8c00');
                    bodyGrad.addColorStop(1, '#ffd700');
                    ctx.fillStyle = bodyGrad;
                    ctx.beginPath();
                    ctx.ellipse(5, 0, 20, 8, 0, 0, Math.PI*2);
                    ctx.fill();

                    ctx.fillStyle = '#ff4500';
                    ctx.beginPath();
                    ctx.moveTo(15, -5); ctx.lineTo(10, -15); ctx.lineTo(20, -12); 
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(20, 0, 10, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.moveTo(28, -3); ctx.lineTo(40, 0); ctx.lineTo(28, 3);
                    ctx.fill();

                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(22, -3, 2.5, 0, Math.PI*2);
                    ctx.fill();
                }
            }

            // --- INIT ---
            const dragon = new Dragon();
            const phoenix = new Phoenix();

            function animate() {
                ctx.clearRect(0, 0, width, height);

                for(let i=particles.length-1; i>=0; i--) {
                    particles[i].update();
                    particles[i].draw(ctx);
                    if(particles[i].life <= 0) particles.splice(i, 1);
                }

                for(let i=activeBeams.length-1; i>=0; i--) {
                    activeBeams[i].draw(ctx);
                    if(activeBeams[i].life <= 0) activeBeams.splice(i, 1);
                }

                dragon.update(phoenix);
                dragon.draw(ctx);

                phoenix.update(dragon);
                phoenix.draw(ctx);

                if (dist(dragon.segments[0].x, dragon.segments[0].y, phoenix.x, phoenix.y) < 60) { // TƒÉng v√πng va ch·∫°m ch√∫t
                    triggerShake();
                    triggerFlash();
                    dragon.target.x -= Math.cos(dragon.angle) * 150; // B·∫≠t l·∫°i xa h∆°n
                    phoenix.target.x -= Math.cos(phoenix.angle) * 150;
                    
                    // N·ªï r·∫•t to
                    for(let i=0; i<30; i++) {
                        particles.push(new Particle((dragon.segments[0].x+phoenix.x)/2, (dragon.segments[0].y+phoenix.y)/2, '#ffffff', 'spark'));
                    }
                }

                requestAnimationFrame(animate);
            }

            // Text Destruction (Gi·ªØ nguy√™n)
            document.addEventListener('mousemove', (e) => {
                 // Check destruction logic here if needed for mouse interaction
            });

            animate();
        };
    </script>
</body>
</html>
